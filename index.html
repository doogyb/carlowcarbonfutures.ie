<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Sashas Site2.0</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.2.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.2.0/mapbox-gl.js"></script>
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>


  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
  </style>
</head>

<body>
  <style>
    .mapboxgl-popup {
      max-width: 400px;
      font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
    }

    #map {
      position: absolute;
      left: 25%;
      top: 0;
      bottom: 0;
      width: 75%;
    }

    .map-overlay {
      position: absolute;
      width: 25%;
      top: 0;
      bottom: 0;
      left: 0;
      font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
      background-color: #fff;
      max-height: 100%;
      overflow: hidden;
    }

    .map-overlay fieldset {
      display: none;
      background: #ddd;
      border: none;
      padding: 10px;
      margin: 0;
    }

    .map-overlay input {
      display: block;
      border: none;
      width: 100%;
      border-radius: 3px;
      padding: 10px;
      margin: 0;
      box-sizing: border-box;
    }

    .map-overlay .listing {
      overflow: auto;
      max-height: 100%;
    }

    .map-overlay .listing>* {
      display: block;
      padding: 5px 10px;
      margin: 0;
    }

    .map-overlay .listing a {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      color: #404;
      text-decoration: none;
    }

    .map-overlay .listing a:last-child {
      border: none;
    }

    .map-overlay .listing a:hover {
      background: #f0f0f0;
    }
  </style>

  <div class="map-overlay">
    <fieldset>
      <input id="feature-filter" type="text" placeholder="Filter results by name">
    </fieldset>
    <div id="feature-listing" class="listing"></div>
  </div>
  <div id="map"></div>

  <script>
    mapboxgl.accessToken =
      "pk.eyJ1Ijoic2FzaGFrdXNobmlyZW5rbyIsImEiOiJja283M3VtcmgwNWg2MnFxa2Y2YWR6Mm54In0.MCYIixuDXkWh5MRGL_CygA";
    var map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/sashakushnirenko/ckohjektd4qa417olala88gwt",
      center: [-6.840328, 52.695250],
  zoom: 9
    });
    var filterEl = document.getElementById('feature-filter');
    var listingEl = document.getElementById('feature-listing');

    var popup = new mapboxgl.Popup({
      closeButton: false
    });

    function renderListings(features) {
      var empty = document.createElement('p');
      // Clear any existing listings
      listingEl.innerHTML = '';
      if (features.length) {
        features.forEach(function (feature) {
          var prop = feature.properties;
          var item = document.createElement('a');
          item.href = prop.link;
          item.target = '_blank';
          if (prop.title) {
            item.textContent = prop.title;
          }
          else {
            item.textContent = "placeholder"
          }
          item.addEventListener('mouseover', function () {
            // Highlight corresponding feature on the map
            popup
              .setLngLat(feature.geometry.coordinates)
              .setText(
                feature.properties.title
              )
              .addTo(map);
          });
          listingEl.appendChild(item);
        });

        // Show the filter input
        filterEl.parentNode.style.display = 'block';
      } else if (features.length === 0 && filterEl.value !== '') {
        empty.textContent = 'No results found';
        listingEl.appendChild(empty);
      } else {
        empty.textContent = 'Drag the map to populate results';
        listingEl.appendChild(empty);

        // Hide the filter input
        filterEl.parentNode.style.display = 'none';

        // remove features filter
        map.setFilter('airport', ['has', 'abbrev']);
      }
    }

    function normalize(string) {
      return string.trim().toLowerCase();
    }

    function getUniqueFeatures(array, comparatorProperty) {
      var existingFeatureKeys = {};
      // Because features come from tiled vector data, feature geometries may be split
      // or duplicated across tile boundaries and, as a result, features may appear
      // multiple times in query results.
      var uniqueFeatures = array.filter(function (el) {
        if (existingFeatureKeys[el.properties[comparatorProperty]]) {
          return false;
        } else {
          existingFeatureKeys[el.properties[comparatorProperty]] = true;
          return true;
        }
      });

      return uniqueFeatures;
    }

    map.on("load", function () {
      // Add a new source from our GeoJSON data and
      // set the 'cluster' option to true. GL-JS will
      // add the point_count property to your source data.
      map.addSource("earthquakes", {
        type: "geojson",
        // Point to GeoJSON data. This example visualizes all M1.0+ earthquakes
        // from 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program.
        data:
          "https://raw.githubusercontent.com/doogyb/sashas-site/main/carlow.geojson",
        cluster: true,
        clusterMaxZoom: 14, // Max zoom to cluster points on
        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
      });

      map.addLayer({
        id: "clusters",
        type: "circle",
        source: "earthquakes",
        filter: ["has", "point_count"],
        paint: {
          // Use step expressions (https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
          // with three steps to implement three types of circles:
          //   * Blue, 20px circles when point count is less than 100
          //   * Yellow, 30px circles when point count is between 100 and 750
          //   * Pink, 40px circles when point count is greater than or equal to 750
          "circle-color": [
            "step",
            ["get", "point_count"],
            "#e86833",
            100,
            "#f1f075",
            750,
            "#f28cb1"
          ],
          "circle-radius": ["step", ["get", "point_count"], 20, 100, 30, 750, 50]
        }
      });

      map.addLayer({
        id: "cluster-count",
        type: "symbol",
        source: "earthquakes",
        filter: ["has", "point_count"],
        layout: {
          "text-field": "{point_count_abbreviated}",
          "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
          "text-size": 12
                 }
      });

      map.addLayer({
        id: "unclustered-point",
        type: "circle",
        source: "earthquakes",
        filter: ["!", ["has", "point_count"]],
        paint: {
          "circle-color": "#f05e22",
          "circle-radius": 5,
          "circle-stroke-width": 1,
          "circle-stroke-color": "#fff"
        }
      });

      // inspect a cluster on click
      map.on("click", "clusters", function (e) {
        var features = map.queryRenderedFeatures(e.point, {
          layers: ["clusters"]
        });
        var clusterId = features[0].properties.cluster_id;
        map
          .getSource("earthquakes")
          .getClusterExpansionZoom(clusterId, function (err, zoom) {
            if (err) return;

            map.easeTo({
              center: features[0].geometry.coordinates,
              zoom: zoom
            });
          });
      });

      // When a click event occurs on a feature in
      // the unclustered-point layer, open a popup at
      // the location of the feature, with
      // description HTML from its properties.
      map.on("click", "unclustered-point", function (e) {
        var coordinates = e.features[0].geometry.coordinates.slice();
        var title = e.features[0].properties.title;
        var link = e.features[0].properties.link;
        var student = e.features[0].properties.student;

        // Ensure that if the map is zoomed out such that
        // multiple copies of the feature are visible, the
        // popup appears over the copy being pointed to.
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }

        new mapboxgl.Popup()
          .setLngLat(coordinates)
          .setHTML(
            "<h3>" +
            student +
            '</h3><p><a href="' +
            link +
            '" target="_blank" title="Opens in a new window">' +
            "</h3><p>" +
            title +
            "</p>"
          )
          .addTo(map);
      });

      map.on("mouseenter", "clusters", function () {
        map.getCanvas().style.cursor = "pointer";
      });
      map.on("mouseleave", "clusters", function () {
        map.getCanvas().style.cursor = "";
      });

      map.on('movestart', function () {
        // reset features filter as the map starts moving
        map.setFilter('unclustered-point', ['has', 'title']);
      });

      map.on('moveend', function () {
        var features = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
        if (features) {
          // Populate features for the listing overlay.
          renderListings(features);
          // Clear the input container
          filterEl.value = '';
          // Store the current features in sn `airports` variable to
          // later use for filtering on `keyup`.
          airports = features;
        }
      });

      filterEl.addEventListener('keyup', function (e) {

        var value = normalize(e.target.value);
        // Filter visible features that don't match the input value.
        var filtered = airports.filter(function (feature) {
          var name = normalize(feature.properties.title);
          return name.indexOf(value) > -1;
        });
        // Populate the sidebar with filtered results
        renderListings(filtered);

        console.log(filtered);

        function onlyUnique(value, index, self) {
          return self.indexOf(value) === index;
        }

        console.log(filtered.map(function (feature) {
          return feature.properties.title;
        }).filter(onlyUnique));

        // Set the filter to populate features into the layer.
        if (filtered.length) {
          map.setFilter('unclustered-point', [
            'match',
            ['get', 'title'],
            filtered.map(function (feature) {
              return feature.properties.title;
            }).filter(onlyUnique),
            true,
            false
          ]);
        }
      });

      // Call this function on initialization
      // passing an empty array to render an empty state
      renderListings([]);

    });


  </script>

  <script>
    if (window.netlifyIdentity) {
      window.netlifyIdentity.on("init", user => {
        if (!user) {
          window.netlifyIdentity.on("login", () => {
            document.location.href = "/admin/";
          });
        }
      });
    }
  </script>

</body>

</html>
